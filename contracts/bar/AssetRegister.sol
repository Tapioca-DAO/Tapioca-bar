// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import './interfaces/IStrategy.sol';
import '@boringcrypto/boring-solidity/contracts/libraries/BoringAddress.sol';
import './ERC1155.sol';

// An asset is a token + a strategy
struct Asset {
    TokenType tokenType;
    address contractAddress;
    IStrategy strategy;
    uint256 tokenId;
}

contract AssetRegister is ERC1155 {
    using BoringAddress for address;

    event AssetRegistered(
        TokenType indexed tokenType,
        address indexed contractAddress,
        IStrategy strategy,
        uint256 indexed tokenId,
        uint256 assetId
    );

    // ids start at 1 so that id 0 means it's not yet registered
    mapping(TokenType => mapping(address => mapping(IStrategy => mapping(uint256 => uint256))))
        public ids;
    Asset[] public assets;

    constructor() {
        assets.push(Asset(TokenType.None, address(0), NO_STRATEGY, 0));
    }

    function assetCount() public view returns (uint256) {
        return assets.length;
    }

    function _registerAsset(
        TokenType tokenType,
        address contractAddress,
        IStrategy strategy,
        uint256 tokenId
    ) internal virtual returns (uint256 assetId) {
        // Checks
        assetId = ids[tokenType][contractAddress][strategy][tokenId];

        // If assetId is 0, this is a new asset that needs to be registered
        if (assetId == 0) {
            // Only do these checks if a new asset needs to be created
            require(
                tokenId == 0 || tokenType != TokenType.ERC20,
                'YieldBox: No tokenId for ERC20'
            );
            require(
                strategy == NO_STRATEGY ||
                    (tokenType == strategy.tokenType() &&
                        contractAddress == strategy.contractAddress() &&
                        tokenId == strategy.tokenId()),
                'YieldBox: Strategy mismatch'
            );
            // If a new token gets added, the isContract checks that this is a deployed contract. Needed for security.
            // Prevents getting shares for a future token whose address is known in advance. For instance a token that
            // will be deployed with CREATE2 in the future or while the contract creation is in the mempool
            require(
                (tokenType == TokenType.Native &&
                    contractAddress == address(0)) ||
                    contractAddress.isContract(),
                'YieldBox: Not a token'
            );

            // Effects
            assetId = assets.length;
            assets.push(Asset(tokenType, contractAddress, strategy, tokenId));
            ids[tokenType][contractAddress][strategy][tokenId] = assetId;

            // The actual URI isn't emitted here as per EIP1155, because that would make this call super expensive.
            emit URI('', assetId);
            emit AssetRegistered(
                tokenType,
                contractAddress,
                strategy,
                tokenId,
                assetId
            );
        }
    }

    function registerAsset(
        TokenType tokenType,
        address contractAddress,
        IStrategy strategy,
        uint256 tokenId
    ) public returns (uint256 assetId) {
        // Native assets can only be added internally by the NativeTokenFactory
        require(
            tokenType == TokenType.ERC20 || tokenType == TokenType.ERC1155,
            'AssetManager: cannot add Native'
        );
        assetId = _registerAsset(tokenType, contractAddress, strategy, tokenId);
    }
}
